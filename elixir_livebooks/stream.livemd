<!-- vim: syntax=markdown -->

# Stream

Functions for creating and composing streams.

Streams are composable, lazy enumerables (for an introduction on
enumerables, see the `Enum` module). Any enumerable that generates
elements one by one during enumeration is called a stream. For example,
Elixir's `Range` is a stream:

```elixir
range = 1..5
```
```elixir
Enum.map(range, &(&1 * 2))
```
In the example above, as we mapped over the range, the elements being
enumerated were created one by one, during enumeration. The `Stream`
module allows us to map the range, without triggering its enumeration:

```elixir
range = 1..3
stream = Stream.map(range, &(&1 * 2))
Enum.map(stream, &(&1 + 1))
```
Note that we started with a range and then we created a stream that is
meant to multiply each element in the range by 2. At this point, no
computation was done. Only when `Enum.map/2` is called we actually
enumerate over each element in the range, multiplying it by 2 and adding 1.
We say the functions in `Stream` are *lazy* and the functions in `Enum`
are *eager*.

Due to their laziness, streams are useful when working with large
(or even infinite) collections. When chaining many operations with `Enum`,
intermediate lists are created, while `Stream` creates a recipe of
computations that are executed at a later moment. Let's see another
example:

```elixir
1..3
|> Enum.map(&IO.inspect(&1))
|> Enum.map(&(&1 * 2))
|> Enum.map(&IO.inspect(&1))

1
2
3
2
4
6
# => [2, 4, 6]
```
Note that we first printed each element in the list, then multiplied each
element by 2 and finally printed each new value. In this example, the list
was enumerated three times. Let's see an example with streams:

```elixir
stream =
  1..3
  |> Stream.map(&IO.inspect(&1))
  |> Stream.map(&(&1 * 2))
  |> Stream.map(&IO.inspect(&1))

Enum.to_list(stream)
1
2
2
4
3
6
# => [2, 4, 6]
```
Although the end result is the same, the order in which the elements were
printed changed! With streams, we print the first element and then print
its double. In this example, the list was enumerated just once!

That's what we meant when we said earlier that streams are composable,
lazy enumerables. Note that we could call `Stream.map/2` multiple times,
effectively composing the streams and keeping them lazy. The computations
are only performed when you call a function from the `Enum` module.

Like with `Enum`, the functions in this module work in linear time. This
means that, the time it takes to perform an operation grows at the same
rate as the length of the list. This is expected on operations such as
`Stream.map/2`. After all, if we want to traverse every element on a
stream, the longer the stream, the more elements we need to traverse,
and the longer it will take.

## Creating Streams

There are many functions in Elixir's standard library that return
streams, some examples are:

  * `IO.stream/2`         - streams input lines, one by one
  * `URI.query_decoder/1` - decodes a query string, pair by pair

This module also provides many convenience functions for creating streams,like `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.

Note the functions in this module are guaranteed to return enumerables.
Since enumerables can have different shapes (structs, anonymous functions,
and so on), the functions in this module may return any of those shapes
and this may change at any time. For example, a function that today
returns an anonymous function may return a struct in future releases.

## Function chunk_by/2

Chunks the `enum` by buffering elements for which `fun` returns the same value.

Elements are only emitted when `fun` returns a new value or the `enum` finishes.

## Examples

```elixir
stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))
Enum.to_list(stream)
```

## Function chunk_every/2

Shortcut to `chunk_every(enum, count, count)`.

## Function chunk_every/4

Streams the enumerable in chunks, containing `count` elements each,
where each new chunk starts `step` elements into the enumerable.

`step` is optional and, if not passed, defaults to `count`, i.e.
chunks do not overlap.

If the last chunk does not have `count` elements to fill the chunk,
elements are taken from `leftover` to fill in the chunk. If `leftover`
does not have enough elements to fill the chunk, then a partial chunk
is returned with less than `count` elements.

If `:discard` is given in `leftover`, the last chunk is discarded
unless it has exactly `count` elements.

## Examples

```elixir
Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list()
```
```elixir
Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |> Enum.to_list()
```
```elixir
Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list()
```
```elixir
Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list()
```

## Function chunk_while/4

Chunks the `enum` with fine grained control when every chunk is emitted.

`chunk_fun` receives the current element and the accumulator and
must return `{:cont, element, acc}` to emit the given chunk and
continue with accumulator or `{:cont, acc}` to not emit any chunk
and continue with the return accumulator.

`after_fun` is invoked when iteration is done and must also return
`{:cont, element, acc}` or `{:cont, acc}`.

## Examples

```elixir
chunk_fun = fn element, acc ->
  if rem(element, 2) == 0 do
    {:cont, Enum.reverse([element | acc]), []}
  else
    {:cont, [element | acc]}
  end
end

after_fun = fn
  [] -> {:cont, []}
  acc -> {:cont, Enum.reverse(acc), []}
end

stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)
Enum.to_list(stream)
```

## Function concat/1

Creates a stream that enumerates each enumerable in an enumerable.

## Examples

```elixir
stream = Stream.concat([1..3, 4..6, 7..9])
Enum.to_list(stream)
```

## Function concat/2

Creates a stream that enumerates the first argument, followed by the second.

## Examples

```elixir
stream = Stream.concat(1..3, 4..6)
Enum.to_list(stream)
```
```elixir
stream1 = Stream.cycle([1, 2, 3])
stream2 = Stream.cycle([4, 5, 6])
stream = Stream.concat(stream1, stream2)
Enum.take(stream, 6)
```

## Function cycle/1

Creates a stream that cycles through the given enumerable,
infinitely.

## Examples

```elixir
stream = Stream.cycle([1, 2, 3])
Enum.take(stream, 5)
```

## Function dedup/1

Creates a stream that only emits elements if they are different from the last emitted element.

This function only ever needs to store the last emitted element.

Elements are compared using `===/2`.

## Examples

```elixir
Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list()
```

## Function dedup_by/2

Creates a stream that only emits elements if the result of calling `fun` on the element is
different from the (stored) result of calling `fun` on the last emitted element.

## Examples

```elixir
Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list()
```

## Function drop/2

Lazily drops the next `n` elements from the enumerable.

If a negative `n` is given, it will drop the last `n` elements from
the collection. Note that the mechanism by which this is implemented
will delay the emission of any element until `n` additional elements have
been emitted by the enum.

## Examples

```elixir
stream = Stream.drop(1..10, 5)
Enum.to_list(stream)
```
```elixir
stream = Stream.drop(1..10, -5)
Enum.to_list(stream)
```

## Function drop_every/2

Creates a stream that drops every `nth` element from the enumerable.

The first element is always dropped, unless `nth` is 0.

`nth` must be a non-negative integer.

## Examples

```elixir
stream = Stream.drop_every(1..10, 2)
Enum.to_list(stream)
```
```elixir
stream = Stream.drop_every(1..1000, 1)
Enum.to_list(stream)
```
```elixir
stream = Stream.drop_every([1, 2, 3, 4, 5], 0)
Enum.to_list(stream)
```

## Function drop_while/2

Lazily drops elements of the enumerable while the given
function returns a truthy value.

## Examples

```elixir
stream = Stream.drop_while(1..10, &(&1 <= 5))
Enum.to_list(stream)
```

## Function each/2

Executes the given function for each element.

Useful for adding side effects (like printing) to a stream.

## Examples

```elixir
stream = Stream.each([1, 2, 3], fn x -> send(self(), x) end)
Enum.to_list(stream)
receive do: (x when is_integer(x) -> x)
```
```elixir
receive do: (x when is_integer(x) -> x)
```
```elixir
receive do: (x when is_integer(x) -> x)
```

## Function filter/2

Creates a stream that filters elements according to
the given function on enumeration.

## Examples

```elixir
stream = Stream.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)
Enum.to_list(stream)
```

## Function flat_map/2

Maps the given `fun` over `enumerable` and flattens the result.

This function returns a new stream built by appending the result of invoking `fun`
on each element of `enumerable` together.

## Examples

```elixir
stream = Stream.flat_map([1, 2, 3], fn x -> [x, x * 2] end)
Enum.to_list(stream)
```
```elixir
stream = Stream.flat_map([1, 2, 3], fn x -> [[x]] end)
Enum.to_list(stream)
```

## Function intersperse/2

Lazily intersperses `intersperse_element` between each element of the enumeration.

## Examples

```elixir
Stream.intersperse([1, 2, 3], 0) |> Enum.to_list()
```
```elixir
Stream.intersperse([1], 0) |> Enum.to_list()
```
```elixir
Stream.intersperse([], 0) |> Enum.to_list()
```

## Function interval/1

Creates a stream that emits a value after the given period `n`
in milliseconds.

The values emitted are an increasing counter starting at `0`.
This operation will block the caller by the given interval
every time a new element is streamed.

Do not use this function to generate a sequence of numbers.
If blocking the caller process is not necessary, use
`Stream.iterate(0, & &1 + 1)` instead.

## Examples

```elixir
Stream.interval(10) |> Enum.take(10)
```

## Function into/3

Injects the stream values into the given collectable as a side-effect.

This function is often used with `run/1` since any evaluation
is delayed until the stream is executed. See `run/1` for an example.

## Function iterate/2

Emits a sequence of values, starting with `start_value`. Successive
values are generated by calling `next_fun` on the previous value.

## Examples

```elixir
Stream.iterate(0, &(&1 + 1)) |> Enum.take(5)
```

## Function map/2

Creates a stream that will apply the given function on
enumeration.

## Examples

```elixir
stream = Stream.map([1, 2, 3], fn x -> x * 2 end)
Enum.to_list(stream)
```

## Function map_every/3

Creates a stream that will apply the given function on
every `nth` element from the enumerable.

The first element is always passed to the given function.

`nth` must be a non-negative integer.

## Examples

```elixir
stream = Stream.map_every(1..10, 2, fn x -> x * 2 end)
Enum.to_list(stream)
```
```elixir
stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -> x * 2 end)
Enum.to_list(stream)
```
```elixir
stream = Stream.map_every(1..5, 0, fn x -> x * 2 end)
Enum.to_list(stream)
```

## Function reject/2

Creates a stream that will reject elements according to
the given function on enumeration.

## Examples

```elixir
stream = Stream.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)
Enum.to_list(stream)
```

## Function repeatedly/1

Returns a stream generated by calling `generator_fun` repeatedly.

## Examples

```elixir
# Although not necessary, let's seed the random algorithm
```

```elixir
:rand.seed(:exsss, {1, 2, 3})
Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)
```

## Function resource/3

Emits a sequence of values for the given resource.

Similar to `transform/3` but the initial accumulated value is
computed lazily via `start_fun` and executes an `after_fun` at
the end of enumeration (both in cases of success and failure).

Successive values are generated by calling `next_fun` with the
previous accumulator (the initial value being the result returned
by `start_fun`) and it must return a tuple containing a list
of elements to be emitted and the next accumulator. The enumeration
finishes if it returns `{:halt, acc}`.

As the name says, this function is useful to stream values from
resources.

## Examples

```elixir
Stream.resource(
  fn -> File.open!("sample") end,
  fn file ->
    case IO.read(file, :line) do
      data when is_binary(data) -> {[data], file}
      _ -> {:halt, file}
    end
  end,
  fn file -> File.close(file) end
)
```

```elixir
Stream.resource(
  fn ->
    {:ok, pid} = StringIO.open("string")
    pid
  end,
  fn pid ->
    case IO.getn(pid, "", 1) do
      :eof -> {:halt, pid}
      char -> {[char], pid}
    end
  end,
  fn pid -> StringIO.close(pid) end
)
|> Enum.to_list()
```

## Function run/1

Runs the given stream.

This is useful when a stream needs to be run, for side effects,
and there is no interest in its return result.

## Examples

Open up a file, replace all `#` by `%` and stream to another file
without loading the whole file in memory:

```elixir
File.stream!("/path/to/file")
|> Stream.map(&String.replace(&1, "#", "%"))
|> Stream.into(File.stream!("/path/to/other/file"))
|> Stream.run()
```
No computation will be done until we call one of the `Enum` functions
or `run/1`.

## Function scan/2

Creates a stream that applies the given function to each
element, emits the result and uses the same result as the accumulator
for the next computation. Uses the first element in the enumerable
as the starting value.

## Examples

```elixir
stream = Stream.scan(1..5, &(&1 + &2))
Enum.to_list(stream)
```

## Function scan/3

Creates a stream that applies the given function to each
element, emits the result and uses the same result as the accumulator
for the next computation. Uses the given `acc` as the starting value.

## Examples

```elixir
stream = Stream.scan(1..5, 0, &(&1 + &2))
Enum.to_list(stream)
```

## Function take/2

Lazily takes the next `count` elements from the enumerable and stops
enumeration.

If a negative `count` is given, the last `count` values will be taken.
For such, the collection is fully enumerated keeping up to `2 * count`
elements in memory. Once the end of the collection is reached,
the last `count` elements will be executed. Therefore, using
a negative `count` on an infinite collection will never return.

## Examples

```elixir
stream = Stream.take(1..100, 5)
Enum.to_list(stream)
```
```elixir
stream = Stream.take(1..100, -5)
Enum.to_list(stream)
```
```elixir
stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)
Enum.to_list(stream)
```

## Function take_every/2

Creates a stream that takes every `nth` element from the enumerable.

The first element is always included, unless `nth` is 0.

`nth` must be a non-negative integer.

## Examples

```elixir
stream = Stream.take_every(1..10, 2)
Enum.to_list(stream)
```
```elixir
stream = Stream.take_every([1, 2, 3, 4, 5], 1)
Enum.to_list(stream)
```
```elixir
stream = Stream.take_every(1..1000, 0)
Enum.to_list(stream)
```

## Function take_while/2

Lazily takes elements of the enumerable while the given
function returns a truthy value.

## Examples

```elixir
stream = Stream.take_while(1..100, &(&1 <= 5))
Enum.to_list(stream)
```

## Function timer/1

Creates a stream that emits a single value after `n` milliseconds.

The value emitted is `0`. This operation will block the caller by
the given time until the element is streamed.

## Examples

```elixir
Stream.timer(10) |> Enum.to_list()
```

## Function transform/3

Transforms an existing stream.

It expects an accumulator and a function that receives each stream element
and an accumulator. It must return a tuple, where the first element is a new
stream (often a list) or the atom `:halt`, and the second element is the
accumulator to be used by the next element, if any, in both cases.

Note: this function is equivalent to `Enum.flat_map_reduce/3`, except this
function does not return the accumulator once the stream is processed.

## Examples

`Stream.transform/3` is useful as it can be used as the basis to implement
many of the functions defined in this module. For example, we can implement
`Stream.take(enum, n)` as follows:

```elixir
enum = 1001..9999
n = 3

stream =
  Stream.transform(enum, 0, fn i, acc ->
    if acc < n, do: {[i], acc + 1}, else: {:halt, acc}
  end)

Enum.to_list(stream)
```

## Function transform/4

Transforms an existing stream with function-based start and finish.

The accumulator is only calculated when transformation starts. It also
allows an after function to be given which is invoked when the stream
halts or completes.

This function can be seen as a combination of `Stream.resource/3` with
`Stream.transform/3`.

## Function unfold/2

Emits a sequence of values for the given accumulator.

Successive values are generated by calling `next_fun` with the previous
accumulator and it must return a tuple with the current value and next
accumulator. The enumeration finishes if it returns `nil`.

## Examples

```elixir
Stream.unfold(5, fn
  0 -> nil
  n -> {n, n - 1}
end)
|> Enum.to_list()
```

## Function uniq/1

Creates a stream that only emits elements if they are unique.

Keep in mind that, in order to know if an element is unique
or not, this function needs to store all unique values emitted
by the stream. Therefore, if the stream is infinite, the number
of elements stored will grow infinitely, never being garbage-collected.

## Examples

```elixir
Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list()
```

## Function uniq_by/2

Creates a stream that only emits elements if they are unique, by removing the
elements for which function `fun` returned duplicate elements.

The function `fun` maps every element to a term which is used to
determine if two elements are duplicates.

Keep in mind that, in order to know if an element is unique
or not, this function needs to store all unique values emitted
by the stream. Therefore, if the stream is infinite, the number
of elements stored will grow infinitely, never being garbage-collected.

## Example

```elixir
Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list()
```
```elixir
Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end)
|> Enum.to_list()
```

## Function with_index/2

Creates a stream where each element in the enumerable will
be wrapped in a tuple alongside its index.

If an `offset` is given, we will index from the given offset instead of from zero.

## Examples

```elixir
stream = Stream.with_index([1, 2, 3])
Enum.to_list(stream)
```
```elixir
stream = Stream.with_index([1, 2, 3], 3)
Enum.to_list(stream)
```

## Function zip/1

Zips corresponding elements from a finite collection of enumerables
into one stream of tuples.

The zipping finishes as soon as any enumerable in the given collection completes.

## Examples

```elixir
concat = Stream.concat(1..3, 4..6)
cycle = Stream.cycle(["foo", "bar", "baz"])
Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list()
```

## Function zip/2

Zips two enumerables together, lazily.

The zipping finishes as soon as either enumerable completes.

## Examples

```elixir
concat = Stream.concat(1..3, 4..6)
cycle = Stream.cycle([:a, :b, :c])
Stream.zip(concat, cycle) |> Enum.to_list()
```

## Function zip_with/2

Lazily zips corresponding elements from a finite collection of enumerables into a new
enumerable, transforming them with the `zip_fun` function as it goes.

The first element from each of the enums in `enumerables` will be put into a list which is then passed to
the 1-arity `zip_fun` function. Then, the second elements from each of the enums are put into a list and passed to
`zip_fun`, and so on until any one of the enums in `enumerables` completes.

Returns a new enumerable with the results of calling `zip_fun`.

## Examples

```elixir
concat = Stream.concat(1..3, 4..6)
Stream.zip_with([concat, concat], fn [a, b] -> a + b end) |> Enum.to_list()
```
```elixir
concat = Stream.concat(1..3, 4..6)
Stream.zip_with([concat, concat, 1..3], fn [a, b, c] -> a + b + c end) |> Enum.to_list()
```

## Function zip_with/3

Lazily zips corresponding elements from two enumerables into a new one, transforming them with
the `zip_fun` function as it goes.

The `zip_fun` will be called with the first element from `enumerable1` and the first
element from `enumerable2`, then with the second element from each, and so on until
either one of the enumerables completes.

## Examples

```elixir
concat = Stream.concat(1..3, 4..6)
Stream.zip_with(concat, concat, fn a, b -> a + b end) |> Enum.to_list()
```

## Type index

Zero-based index.
