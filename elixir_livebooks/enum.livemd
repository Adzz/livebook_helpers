<!-- vim: syntax=markdown -->

# Enum

Provides a set of algorithms to work with enumerables.

In Elixir, an enumerable is any data type that implements the
`Enumerable` protocol. `List`s (`[1, 2, 3]`), `Map`s (`%{foo: 1, bar: 2}`)
and `Range`s (`1..3`) are common data types used as enumerables:

```elixir
Enum.map([1, 2, 3], fn x -> x * 2 end)
```
```elixir
Enum.sum([1, 2, 3])
```
```elixir
Enum.map(1..3, fn x -> x * 2 end)
```
```elixir
Enum.sum(1..3)
```
```elixir
map = %{"a" => 1, "b" => 2}
Enum.map(map, fn {k, v} -> {k, v * 2} end)
```
However, many other enumerables exist in the language, such as `MapSet`s
and the data type returned by `File.stream!/3` which allows a file to be
traversed as if it was an enumerable.

The functions in this module work in linear time. This means that, the
time it takes to perform an operation grows at the same rate as the length
of the enumerable. This is expected on operations such as `Enum.map/2`.
After all, if we want to traverse every element on a list, the longer the
list, the more elements we need to traverse, and the longer it will take.

This linear behaviour should also be expected on operations like `count/1`,
`member?/2`, `at/2` and similar. While Elixir does allow data types to
provide performant variants for such operations, you should not expect it
to always be available, since the `Enum` module is meant to work with a
large variety of data types and not all data types can provide optimized
behaviour.

Finally, note the functions in the `Enum` module are eager: they will
traverse the enumerable as soon as they are invoked. This is particularly
dangerous when working with infinite enumerables. In such cases, you should
use the `Stream` module, which allows you to lazily express computations,
without traversing collections, and work with possibly infinite collections.
See the `Stream` module for examples and documentation.

## Function all?/1

Returns `true` if all elements in `enumerable` are truthy.

When an element has a falsy value (`false` or `nil`) iteration stops immediately
and `false` is returned. In all other cases `true` is returned.

## Examples

```elixir
Enum.all?([1, 2, 3])
```
```elixir
Enum.all?([1, nil, 3])
```
```elixir
Enum.all?([])
```

## Function all?/2

Returns `true` if `fun.(element)` is truthy for all elements in `enumerable`.

Iterates over `enumerable` and invokes `fun` on each element. If `fun` ever
returns a falsy value (`false` or `nil`), iteration stops immediately and
`false` is returned. Otherwise, `true` is returned.

## Examples

```elixir
Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)
```
```elixir
Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)
```
```elixir
Enum.all?([], fn _ -> nil end)
```
As the last example shows, `Enum.all?/2` returns `true` if `enumerable` is
empty, regardless of `fun`. In an empty enumerable there is no element for
which `fun` returns a falsy value, so the result must be `true`. This is a
well-defined logical argument for empty collections.


## Function any?/1

Returns `true` if at least one element in `enumerable` is truthy.

When an element has a truthy value (neither `false` nor `nil`) iteration stops
immediately and `true` is returned. In all other cases `false` is returned.

## Examples

```elixir
Enum.any?([false, false, false])
```
```elixir
Enum.any?([false, true, false])
```
```elixir
Enum.any?([])
```

## Function any?/2

Returns `true` if `fun.(element)` is truthy for at least one element in `enumerable`.

Iterates over the `enumerable` and invokes `fun` on each element. When an invocation
of `fun` returns a truthy value (neither `false` nor `nil`) iteration stops
immediately and `true` is returned. In all other cases `false` is returned.

## Examples

```elixir
Enum.any?([2, 4, 6], fn x -> rem(x, 2) == 1 end)
```
```elixir
Enum.any?([2, 3, 4], fn x -> rem(x, 2) == 1 end)
```
```elixir
Enum.any?([], fn x -> x > 0 end)
```

## Function at/3

Finds the element at the given `index` (zero-based).

Returns `default` if `index` is out of bounds.

A negative `index` can be passed, which means the `enumerable` is
enumerated once and the `index` is counted from the end (for example,
`-1` finds the last element).

## Examples

```elixir
Enum.at([2, 4, 6], 0)
```
```elixir
Enum.at([2, 4, 6], 2)
```
```elixir
Enum.at([2, 4, 6], 4)
```
```elixir
Enum.at([2, 4, 6], 4, :none)
```

## Function chunk_by/2

Splits enumerable on every element for which `fun` returns a new
value.

Returns a list of lists.

## Examples

```elixir
Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))
```

## Function chunk_every/2

Shortcut to `chunk_every(enumerable, count, count)`.

## Function chunk_every/4

Returns list of lists containing `count` elements each, where
each new chunk starts `step` elements into the `enumerable`.

`step` is optional and, if not passed, defaults to `count`, i.e.
chunks do not overlap.

If the last chunk does not have `count` elements to fill the chunk,
elements are taken from `leftover` to fill in the chunk. If `leftover`
does not have enough elements to fill the chunk, then a partial chunk
is returned with less than `count` elements.

If `:discard` is given in `leftover`, the last chunk is discarded
unless it has exactly `count` elements.

## Examples

```elixir
Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
```
```elixir
Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard)
```
```elixir
Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7])
```
```elixir
Enum.chunk_every([1, 2, 3, 4], 3, 3, [])
```
```elixir
Enum.chunk_every([1, 2, 3, 4], 10)
```
```elixir
Enum.chunk_every([1, 2, 3, 4, 5], 2, 3, [])
```

## Function chunk_while/4

Chunks the `enumerable` with fine grained control when every chunk is emitted.

`chunk_fun` receives the current element and the accumulator and must return:

  * `{:cont, chunk, acc}` to emit a chunk and continue with the accumulator
  * `{:cont, acc}` to not emit any chunk and continue with the accumulator
  * `{:halt, acc}` to halt chunking over the `enumerable`.

`after_fun` is invoked with the final accumulator when iteration isfinished (or `halt`ed) to handle any trailing elements that were returned
as part of an accumulator, but were not emitted as a chunk by `chunk_fun`.
It must return:

  * `{:cont, chunk, acc}` to emit a chunk. The chunk will be appended to the
    list of already emitted chunks.
  * `{:cont, acc}` to not emit a chunk

The `acc` in `after_fun` is required in order to mirror the tuple formatfrom `chunk_fun` but it will be discarded since the traversal is complete.

Returns a list of emitted chunks.

## Examples

```elixir
chunk_fun = fn element, acc ->
  if rem(element, 2) == 0 do
    {:cont, Enum.reverse([element | acc]), []}
  else
    {:cont, [element | acc]}
  end
end

after_fun = fn
  [] -> {:cont, []}
  acc -> {:cont, Enum.reverse(acc), []}
end

Enum.chunk_while(1..10, [], chunk_fun, after_fun)
```
```elixir
Enum.chunk_while([1, 2, 3, 5, 7], [], chunk_fun, after_fun)
```

## Function concat/1

Given an enumerable of enumerables, concatenates the `enumerables` into
a single list.

## Examples

```elixir
Enum.concat([1..3, 4..6, 7..9])
```
```elixir
Enum.concat([[1, [2], 3], [4], [5, 6]])
```

## Function concat/2

Concatenates the enumerable on the `right` with the enumerable on the
`left`.

This function produces the same result as the `Kernel.++/2` operator
for lists.

## Examples

```elixir
Enum.concat(1..3, 4..6)
```
```elixir
Enum.concat([1, 2, 3], [4, 5, 6])
```

## Function count/1

Returns the size of the `enumerable`.

## Examples

```elixir
Enum.count([1, 2, 3])
```

## Function count/2

Returns the count of elements in the `enumerable` for which `fun` returns
a truthy value.

## Examples

```elixir
Enum.count([1, 2, 3, 4, 5], fn x -> rem(x, 2) == 0 end)
```

## Function count_until/2

Counts the enumerable stopping at `limit`.

This is useful for checking certain properties of the count of an enumerable
without having to actually count the entire enumerable. For example, if you
wanted to check that the count was exactly, at least, or more than a value.

If the enumerable implements `c:Enumerable.count/1`, the enumerable is
not traversed and we return the lower of the two numbers. To force
enumeration, use `count_until/3` with `fn _ -> true end` as the second
argument.

## Examples

```elixir
Enum.count_until(1..20, 5)
```
```elixir
Enum.count_until(1..20, 50)
```
```elixir
# At least 10
Enum.count_until(1..10, 10) == 10
```
```elixir
# More than 10
Enum.count_until(1..11, 10 + 1) > 10
```
```elixir
# Less than 10
Enum.count_until(1..5, 10) < 10
```
```elixir
# Exactly ten
Enum.count_until(1..10, 10 + 1) == 10
```

## Function count_until/3

Counts the elements in the enumerable for which `fun` returns a truthy value, stopping at `limit`.

See `count/2` and `count_until/3` for more information.

## Examples

```elixir
Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 7)
```
```elixir
Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 11)
```
## Function dedup/1

Enumerates the `enumerable`, returning a list where all consecutive
duplicated elements are collapsed to a single element.

Elements are compared using `===/2`.

If you want to remove all duplicated elements, regardless of order,
see `uniq/1`.

## Examples

```elixir
Enum.dedup([1, 2, 3, 3, 2, 1])
```
```elixir
Enum.dedup([1, 1, 2, 2.0, :three, :three])
```

## Function dedup_by/2

Enumerates the `enumerable`, returning a list where all consecutive
duplicated elements are collapsed to a single element.

The function `fun` maps every element to a term which is used to
determine if two elements are duplicates.

## Examples

```elixir
Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x end)
```
```elixir
Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)
```

## Function drop/2

Drops the `amount` of elements from the `enumerable`.

If a negative `amount` is given, the `amount` of last values will be dropped.
The `enumerable` will be enumerated once to retrieve the proper index and
the remaining calculation is performed from the end.

## Examples

```elixir
Enum.drop([1, 2, 3], 2)
```
```elixir
Enum.drop([1, 2, 3], 10)
```
```elixir
Enum.drop([1, 2, 3], 0)
```
```elixir
Enum.drop([1, 2, 3], -1)
```

## Function drop_every/2

Returns a list of every `nth` element in the `enumerable` dropped,
starting with the first element.

The first element is always dropped, unless `nth` is 0.

The second argument specifying every `nth` element must be a non-negative
integer.

## Examples

```elixir
Enum.drop_every(1..10, 2)
```
```elixir
Enum.drop_every(1..10, 0)
```
```elixir
Enum.drop_every([1, 2, 3], 1)
```

## Function drop_while/2

Drops elements at the beginning of the `enumerable` while `fun` returns a
truthy value.

## Examples

```elixir
Enum.drop_while([1, 2, 3, 2, 1], fn x -> x < 3 end)
```

## Function each/2

Invokes the given `fun` for each element in the `enumerable`.

Returns `:ok`.

## Examples

```elixir
Enum.each(["some", "example"], fn x -> IO.puts(x) end)
"some"
"example"
# => :ok
```
## Function empty?/1

Determines if the `enumerable` is empty.

Returns `true` if `enumerable` is empty, otherwise `false`.

## Examples

```elixir
Enum.empty?([])
```
```elixir
Enum.empty?([1, 2, 3])
```

## Function fetch/2

Finds the element at the given `index` (zero-based).

Returns `{:ok, element}` if found, otherwise `:error`.

A negative `index` can be passed, which means the `enumerable` is
enumerated once and the `index` is counted from the end (for example,
`-1` fetches the last element).

## Examples

```elixir
Enum.fetch([2, 4, 6], 0)
```
```elixir
Enum.fetch([2, 4, 6], -3)
```
```elixir
Enum.fetch([2, 4, 6], 2)
```
```elixir
Enum.fetch([2, 4, 6], 4)
```

## Function fetch!/2

Finds the element at the given `index` (zero-based).

Raises `OutOfBoundsError` if the given `index` is outside the range of
the `enumerable`.

## Examples

```elixir
Enum.fetch!([2, 4, 6], 0)
```
```elixir
Enum.fetch!([2, 4, 6], 2)
```
```elixir
Enum.fetch!([2, 4, 6], 4)
```

## Function filter/2

Filters the `enumerable`, i.e. returns only those elements
for which `fun` returns a truthy value.

See also `reject/2` which discards all elements where the
function returns a truthy value.

## Examples

```elixir
Enum.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)
```
Keep in mind that `filter` is not capable of filtering and
transforming an element at the same time. If you would like
to do so, consider using `flat_map/2`. For example, if you
want to convert all strings that represent an integer and
discard the invalid one in one pass:

```elixir
strings = ["1234", "abc", "12ab"]

Enum.flat_map(strings, fn string ->
  case Integer.parse(string) do
    # transform to integer
    {int, _rest} -> [int]
    # skip the value
    :error -> []
  end
end)
```
## Function find/3

Returns the first element for which `fun` returns a truthy value.
If no such element is found, returns `default`.

## Examples

```elixir
Enum.find([2, 3, 4], fn x -> rem(x, 2) == 1 end)
```
```elixir
Enum.find([2, 4, 6], fn x -> rem(x, 2) == 1 end)
```
```elixir
Enum.find([2, 4, 6], 0, fn x -> rem(x, 2) == 1 end)
```

## Function find_index/2

Similar to `find/3`, but returns the index (zero-based)
of the element instead of the element itself.

## Examples

```elixir
Enum.find_index([2, 4, 6], fn x -> rem(x, 2) == 1 end)
```
```elixir
Enum.find_index([2, 3, 4], fn x -> rem(x, 2) == 1 end)
```

## Function find_value/3

Similar to `find/3`, but returns the value of the function
invocation instead of the element itself.

The return value is considered to be found when the result is truthy
(neither `nil` nor `false`).

## Examples

```elixir
Enum.find_value([2, 3, 4], fn x ->
  if x > 2, do: x * x
end)
```
```elixir
Enum.find_value([2, 4, 6], fn x -> rem(x, 2) == 1 end)
```
```elixir
Enum.find_value([2, 3, 4], fn x -> rem(x, 2) == 1 end)
```
```elixir
Enum.find_value([1, 2, 3], "no bools!", &is_boolean/1)
```

## Function flat_map/2

Maps the given `fun` over `enumerable` and flattens the result.

This function returns a new enumerable built by appending the result of invoking `fun`
on each element of `enumerable` together; conceptually, this is similar to a
combination of `map/2` and `concat/1`.

## Examples

```elixir
Enum.flat_map([:a, :b, :c], fn x -> [x, x] end)
```
```elixir
Enum.flat_map([{1, 3}, {4, 6}], fn {x, y} -> x..y end)
```
```elixir
Enum.flat_map([:a, :b, :c], fn x -> [[x]] end)
```

## Function flat_map_reduce/3

Maps and reduces an `enumerable`, flattening the given results (only one level deep).

It expects an accumulator and a function that receives each enumerable
element, and must return a tuple containing a new enumerable (often a list)
with the new accumulator or a tuple with `:halt` as first element and
the accumulator as second.

## Examples

```elixir
enumerable = 1..100
n = 3

Enum.flat_map_reduce(enumerable, 0, fn x, acc ->
  if acc < n, do: {[x], acc + 1}, else: {:halt, acc}
end)
```
```elixir
Enum.flat_map_reduce(1..5, 0, fn x, acc -> {[[x]], acc + x} end)
```

## Function frequencies/1

Returns a map with keys as unique elements of `enumerable` and values
as the count of every element.

## Examples

```elixir
Enum.frequencies(~w{ant buffalo ant ant buffalo dingo})
```

## Function frequencies_by/2

Returns a map with keys as unique elements given by `key_fun` and values
as the count of every element.

## Examples

```elixir
Enum.frequencies_by(~w{aa aA bb cc}, &String.downcase/1)
```
```elixir
Enum.frequencies_by(~w{aaa aA bbb cc c}, &String.length/1)
```

## Function group_by/3

Splits the `enumerable` into groups based on `key_fun`.

The result is a map where each key is given by `key_fun`
and each value is a list of elements given by `value_fun`.
The order of elements within each list is preserved from the `enumerable`.
However, like all maps, the resulting map is unordered.

## Examples

```elixir
Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)
```
```elixir
Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1, &String.first/1)
```

## Function intersperse/2

Intersperses `separator` between each element of the enumeration.

## Examples

```elixir
Enum.intersperse([1, 2, 3], 0)
```
```elixir
Enum.intersperse([1], 0)
```
```elixir
Enum.intersperse([], 0)
```

## Function into/2

Inserts the given `enumerable` into a `collectable`.

Note that passing a non-empty list as the `collectable` is deprecated.
If you're collecting into a non-empty keyword list, consider using
`Keyword.merge(collectable, Enum.to_list(enumerable))`. If you're collecting
into a non-empty list, consider something like `Enum.to_list(enumerable) ++ collectable`.

## Examples

```elixir
Enum.into([1, 2], [])
```
```elixir
Enum.into([a: 1, b: 2], %{})
```
```elixir
Enum.into(%{a: 1}, %{b: 2})
```
```elixir
Enum.into([a: 1, a: 2], %{})
```

## Function into/3

Inserts the given `enumerable` into a `collectable` according to the
transformation function.

## Examples

```elixir
Enum.into([1, 2, 3], [], fn x -> x * 3 end)
```
```elixir
Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -> {k, v * 2} end)
```

## Function join/2

Joins the given `enumerable` into a string using `joiner` as a
separator.

If `joiner` is not passed at all, it defaults to an empty string.

All elements in the `enumerable` must be convertible to a string,
otherwise an error is raised.

## Examples

```elixir
Enum.join([1, 2, 3])
```
```elixir
Enum.join([1, 2, 3], " = ")
```

## Function map/2

Returns a list where each element is the result of invoking
`fun` on each corresponding element of `enumerable`.

For maps, the function expects a key-value tuple.

## Examples

```elixir
Enum.map([1, 2, 3], fn x -> x * 2 end)
```
```elixir
Enum.map([a: 1, b: 2], fn {k, v} -> {k, -v} end)
```

## Function map_every/3

Returns a list of results of invoking `fun` on every `nth`
element of `enumerable`, starting with the first element.

The first element is always passed to the given function, unless `nth` is `0`.

The second argument specifying every `nth` element must be a non-negative
integer.

If `nth` is `0`, then `enumerable` is directly converted to a list,
without `fun` being ever applied.

## Examples

```elixir
Enum.map_every(1..10, 2, fn x -> x + 1000 end)
```
```elixir
Enum.map_every(1..10, 3, fn x -> x + 1000 end)
```
```elixir
Enum.map_every(1..5, 0, fn x -> x + 1000 end)
```
```elixir
Enum.map_every([1, 2, 3], 1, fn x -> x + 1000 end)
```

## Function map_intersperse/3

Maps and intersperses the given enumerable in one pass.

## Examples

```elixir
Enum.map_intersperse([1, 2, 3], :a, &(&1 * 2))
```
## Function map_join/3

Maps and joins the given `enumerable` in one pass.

If `joiner` is not passed at all, it defaults to an empty string.

All elements returned from invoking the `mapper` must be convertible to
a string, otherwise an error is raised.

## Examples

```elixir
Enum.map_join([1, 2, 3], &(&1 * 2))
```
```elixir
Enum.map_join([1, 2, 3], " = ", &(&1 * 2))
```

## Function map_reduce/3

Invokes the given function to each element in the `enumerable` to reduce
it to a single element, while keeping an accumulator.

Returns a tuple where the first element is the mapped enumerable and
the second one is the final accumulator.

The function, `fun`, receives two arguments: the first one is the
element, and the second one is the accumulator. `fun` must return
a tuple with two elements in the form of `{result, accumulator}`.

For maps, the first tuple element must be a `{key, value}` tuple.

## Examples

```elixir
Enum.map_reduce([1, 2, 3], 0, fn x, acc -> {x * 2, x + acc} end)
```

## Function max/3

Returns the maximal element in the `enumerable` according
to Erlang's term ordering.

By default, the comparison is done with the `>=` sorter function.
If multiple elements are considered maximal, the first one that
was found is returned. If you want the last element considered
maximal to be returned, the sorter function should not return true
for equal elements.

If the enumerable is empty, the provided `empty_fallback` is called.
The default `empty_fallback` raises `Enum.EmptyError`.

## Examples

```elixir
Enum.max([1, 2, 3])
```
The fact this function uses Erlang's term ordering means that the comparison
is structural and not semantic. For example:

```elixir
Enum.max([~D[2017-03-31], ~D[2017-04-01]])
```
In the example above, `max/2` returned March 31st instead of April 1st
because the structural comparison compares the day before the year.
For this reason, most structs provide a "compare" function, such as
`Date.compare/2`, which receives two structs and returns `:lt` (less-than),
`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the
sorting function, Elixir will automatically use the `compare/2` function
of said module:

```elixir
Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)
```
Finally, if you don't want to raise on empty enumerables, you can pass
the empty fallback:

```elixir
Enum.max([], &>=/2, fn -> 0 end)
```

## Function max_by/4

Returns the maximal element in the `enumerable` as calculated
by the given `fun`.

By default, the comparison is done with the `>=` sorter function.
If multiple elements are considered maximal, the first one that
was found is returned. If you want the last element considered
maximal to be returned, the sorter function should not return true
for equal elements.

Calls the provided `empty_fallback` function and returns its value if
`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.

## Examples

```elixir
Enum.max_by(["a", "aa", "aaa"], fn x -> String.length(x) end)
```
```elixir
Enum.max_by(["a", "aa", "aaa", "b", "bbb"], &String.length/1)
```
The fact this function uses Erlang's term ordering means that the
comparison is structural and not semantic. Therefore, if you want
to compare structs, most structs provide a "compare" function, such as
`Date.compare/2`, which receives two structs and returns `:lt` (less-than),
`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the
sorting function, Elixir will automatically use the `compare/2` function
of said module:

```elixir
users = [
  %{name: "Ellis", birthday: ~D[1943-05-11]},
  %{name: "Lovelace", birthday: ~D[1815-12-10]},
  %{name: "Turing", birthday: ~D[1912-06-23]}
]

Enum.max_by(users, & &1.birthday, Date)
```
Finally, if you don't want to raise on empty enumerables, you can pass
the empty fallback:

```elixir
Enum.max_by([], &String.length/1, fn -> nil end)
```

## Function member?/2

Checks if `element` exists within the `enumerable`.

Membership is tested with the match (`===/2`) operator.

## Examples

```elixir
Enum.member?(1..10, 5)
```
```elixir
Enum.member?(1..10, 5.0)
```
```elixir
Enum.member?([1.0, 2.0, 3.0], 2)
```
```elixir
Enum.member?([1.0, 2.0, 3.0], 2.000)
```
```elixir
Enum.member?([:a, :b, :c], :d)
```

When called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)
operators work by using this function.

## Function min/3

Returns the minimal element in the `enumerable` according
to Erlang's term ordering.

By default, the comparison is done with the `<=` sorter function.
If multiple elements are considered minimal, the first one that
was found is returned. If you want the last element considered
minimal to be returned, the sorter function should not return true
for equal elements.

If the enumerable is empty, the provided `empty_fallback` is called.
The default `empty_fallback` raises `Enum.EmptyError`.

## Examples

```elixir
Enum.min([1, 2, 3])
```
The fact this function uses Erlang's term ordering means that the comparison
is structural and not semantic. For example:

```elixir
Enum.min([~D[2017-03-31], ~D[2017-04-01]])
```
In the example above, `min/2` returned April 1st instead of March 31st
because the structural comparison compares the day before the year.
For this reason, most structs provide a "compare" function, such as
`Date.compare/2`, which receives two structs and returns `:lt` (less-than),
`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the
sorting function, Elixir will automatically use the `compare/2` function
of said module:

```elixir
Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)
```
Finally, if you don't want to raise on empty enumerables, you can pass
the empty fallback:

```elixir
Enum.min([], fn -> 0 end)
```

## Function min_by/4

Returns the minimal element in the `enumerable` as calculated
by the given `fun`.

By default, the comparison is done with the `<=` sorter function.
If multiple elements are considered minimal, the first one that
was found is returned. If you want the last element considered
minimal to be returned, the sorter function should not return true
for equal elements.

Calls the provided `empty_fallback` function and returns its value if
`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.

## Examples

```elixir
Enum.min_by(["a", "aa", "aaa"], fn x -> String.length(x) end)
```
```elixir
Enum.min_by(["a", "aa", "aaa", "b", "bbb"], &String.length/1)
```
The fact this function uses Erlang's term ordering means that the
comparison is structural and not semantic. Therefore, if you want
to compare structs, most structs provide a "compare" function, such as
`Date.compare/2`, which receives two structs and returns `:lt` (less-than),
`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the
sorting function, Elixir will automatically use the `compare/2` function
of said module:

```elixir
users = [
  %{name: "Ellis", birthday: ~D[1943-05-11]},
  %{name: "Lovelace", birthday: ~D[1815-12-10]},
  %{name: "Turing", birthday: ~D[1912-06-23]}
]

Enum.min_by(users, & &1.birthday, Date)
```
Finally, if you don't want to raise on empty enumerables, you can pass
the empty fallback:

```elixir
Enum.min_by([], &String.length/1, fn -> nil end)
```

## Function min_max/2

Returns a tuple with the minimal and the maximal elements in the
enumerable according to Erlang's term ordering.

If multiple elements are considered maximal or minimal, the first one
that was found is returned.

Calls the provided `empty_fallback` function and returns its value if
`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.

## Examples

```elixir
Enum.min_max([2, 3, 1])
```
```elixir
Enum.min_max([], fn -> {nil, nil} end)
```

## Function min_max_by/4

Returns a tuple with the minimal and the maximal elements in the
enumerable as calculated by the given function.

If multiple elements are considered maximal or minimal, the first one
that was found is returned.

## Examples

```elixir
Enum.min_max_by(["aaa", "bb", "c"], fn x -> String.length(x) end)
```
```elixir
Enum.min_max_by(["aaa", "a", "bb", "c", "ccc"], &String.length/1)
```
```elixir
Enum.min_max_by([], &String.length/1, fn -> {nil, nil} end)
```
The fact this function uses Erlang's term ordering means that the
comparison is structural and not semantic. Therefore, if you want
to compare structs, most structs provide a "compare" function, such as
`Date.compare/2`, which receives two structs and returns `:lt` (less-than),
`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the
sorting function, Elixir will automatically use the `compare/2` function
of said module:

```elixir
users = [
  %{name: "Ellis", birthday: ~D[1943-05-11]},
  %{name: "Lovelace", birthday: ~D[1815-12-10]},
  %{name: "Turing", birthday: ~D[1912-06-23]}
]

Enum.min_max_by(users, & &1.birthday, Date)
```
Finally, if you don't want to raise on empty enumerables, you can pass
the empty fallback:

```elixir
Enum.min_max_by([], &String.length/1, fn -> nil end)
```

## Function product/1

Returns the product of all elements.

Raises `ArithmeticError` if `enumerable` contains a non-numeric value.

## Examples

```elixir
Enum.product([])
```
```elixir
Enum.product([2, 3, 4])
```
```elixir
Enum.product([2.0, 3.0, 4.0])
```

## Function random/1

Returns a random element of an `enumerable`.

Raises `Enum.EmptyError` if `enumerable` is empty.

This function uses Erlang's [`:rand` module](`:rand`) to calculate
the random value. Check its documentation for setting a
different random algorithm or a different seed.

The implementation is based on the
[reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)
algorithm.
It assumes that the sample being returned can fit into memory;
the input `enumerable` doesn't have to, as it is traversed just once.

If a range is passed into the function, this function will pick a
random value between the range limits, without traversing the whole
range (thus executing in constant time and constant memory).

## Examples

The examples below use the `:exsss` pseudorandom algorithm since it's
the default from Erlang/OTP 22:

```elixir
# Although not necessary, let's seed the random algorithm
```

```elixir
:rand.seed(:exsss, {100, 101, 102})
Enum.random([1, 2, 3])
```
```elixir
Enum.random([1, 2, 3])
```
```elixir
Enum.random(1..1_000)
```

## Function reduce/2

Invokes `fun` for each element in the `enumerable` with the
accumulator.

Raises `Enum.EmptyError` if `enumerable` is empty.

The first element of the `enumerable` is used as the initial value
of the accumulator. Then, the function is invoked with the next
element and the accumulator. The result returned by the function
is used as the accumulator for the next iteration, recursively.
When the `enumerable` is done, the last accumulator is returned.

Since the first element of the enumerable is used as the initial
value of the accumulator, `fun` will only be executed `n - 1` times
where `n` is the length of the enumerable. This function won't call
the specified function for enumerables that are one-element long.

If you wish to use another value for the accumulator, use
`Enum.reduce/3`.

## Examples

```elixir
Enum.reduce([1, 2, 3, 4], fn x, acc -> x * acc end)
```

## Function reduce/3

Invokes `fun` for each element in the `enumerable` with the accumulator.

The initial value of the accumulator is `acc`. The function is invoked for
each element in the enumerable with the accumulator. The result returned
by the function is used as the accumulator for the next iteration.
The function returns the last accumulator.

## Examples

```elixir
Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)
```
## Reduce as a building block

Reduce (sometimes called `fold`) is a basic building block in functional
programming. Almost all of the functions in the `Enum` module can be
implemented on top of reduce. Those functions often rely on other operations,
such as `Enum.reverse/1`, which are optimized by the runtime.

For example, we could implement `map/2` in terms of `reduce/3` as follows:

```elixir
def my_map(enumerable, fun) do
  enumerable
  |> Enum.reduce([], fn x, acc -> [fun.(x) | acc] end)
  |> Enum.reverse()
end
```
In the example above, `Enum.reduce/3` accumulates the result of each call
to `fun` into a list in reverse order, which is correctly ordered at the
end by calling `Enum.reverse/1`.

Implementing functions like `map/2`, `filter/2` and others are a good
exercise for understanding the power behind `Enum.reduce/3`. When an
operation cannot be expressed by any of the functions in the `Enum`
module, developers will most likely resort to `reduce/3`.

## Function reduce_while/3

Reduces `enumerable` until `fun` returns `{:halt, term}`.

The return value for `fun` is expected to be

  * `{:cont, acc}` to continue the reduction with `acc` as the new
    accumulator or
  * `{:halt, acc}` to halt the reduction

If `fun` returns `{:halt, acc}` the reduction is halted and the functionreturns `acc`. Otherwise, if the enumerable is exhausted, the function returns
the accumulator of the last `{:cont, acc}`.

## Examples

```elixir
Enum.reduce_while(1..100, 0, fn x, acc ->
  if x < 5, do: {:cont, acc + x}, else: {:halt, acc}
end)
```
```elixir
Enum.reduce_while(1..100, 0, fn x, acc ->
  if x > 0, do: {:cont, acc + x}, else: {:halt, acc}
end)
```

## Function reject/2

Returns a list of elements in `enumerable` excluding those for which the function `fun` returns
a truthy value.

See also `filter/2`.

## Examples

```elixir
Enum.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)
```

## Function reverse/1

Returns a list of elements in `enumerable` in reverse order.

## Examples

```elixir
Enum.reverse([1, 2, 3])
```

## Function reverse/2

Reverses the elements in `enumerable`, appends the `tail`, and returns
it as a list.

This is an optimization for
`enumerable |> Enum.reverse() |> Enum.concat(tail)`.

## Examples

```elixir
Enum.reverse([1, 2, 3], [4, 5, 6])
```

## Function reverse_slice/3

Reverses the `enumerable` in the range from initial `start_index`
through `count` elements.

If `count` is greater than the size of the rest of the `enumerable`,
then this function will reverse the rest of the enumerable.

## Examples

```elixir
Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)
```

## Function scan/2

Applies the given function to each element in the `enumerable`,
storing the result in a list and passing it as the accumulator
for the next computation. Uses the first element in the `enumerable`
as the starting value.

## Examples

```elixir
Enum.scan(1..5, &(&1 + &2))
```

## Function scan/3

Applies the given function to each element in the `enumerable`,
storing the result in a list and passing it as the accumulator
for the next computation. Uses the given `acc` as the starting value.

## Examples

```elixir
Enum.scan(1..5, 0, &(&1 + &2))
```

## Function shuffle/1

Returns a list with the elements of `enumerable` shuffled.

This function uses Erlang's [`:rand` module](`:rand`) to calculate
the random value. Check its documentation for setting a
different random algorithm or a different seed.

## Examples

The examples below use the `:exsss` pseudorandom algorithm since it's
the default from Erlang/OTP 22:

```elixir
# Although not necessary, let's seed the random algorithm
```

```elixir
:rand.seed(:exsss, {1, 2, 3})
Enum.shuffle([1, 2, 3])
```
```elixir
Enum.shuffle([1, 2, 3])
```

## Function slice/2

Returns a subset list of the given `enumerable` by `index_range`.

`index_range` must be a `Range`. Given an `enumerable`, it drops
elements before `index_range.first` (zero-base), then it takes elements
until element `index_range.last` (inclusively).

Indexes are normalized, meaning that negative indexes will be counted
from the end (for example, `-1` means the last element of the `enumerable`).

If `index_range.last` is out of bounds, then it is assigned as the index
of the last element.

If the normalized `index_range.first` is out of bounds of the given
`enumerable`, or this one is greater than the normalized `index_range.last`,
then `[]` is returned.

## Examples

```elixir
Enum.slice(1..100, 5..10)
```
```elixir
Enum.slice(1..10, 5..20)
```
```elixir
# last five elements (negative indexes)
```

```elixir
Enum.slice(1..30, -5..-1)
```
For ranges where `start > stop`, you need to explicit
mark them as increasing:

```elixir
Enum.slice(1..30, 25..-1//1)
```
If values are out of bounds, it returns an empty list:

```elixir
Enum.slice(1..10, 11..20)
```
```elixir
# first is greater than last
```

```elixir
Enum.slice(1..10, 6..5)
```

## Function slice/3

Returns a subset list of the given `enumerable`, from `start_index` (zero-based)
with `amount` number of elements if available.

Given an `enumerable`, it drops elements right before element `start_index`;
then, it takes `amount` of elements, returning as many elements as possible if
there are not enough elements.

A negative `start_index` can be passed, which means the `enumerable` is
enumerated once and the index is counted from the end (for example,
`-1` starts slicing from the last element).

It returns `[]` if `amount` is `0` or if `start_index` is out of bounds.

## Examples

```elixir
Enum.slice(1..100, 5, 10)
```
```elixir
# amount to take is greater than the number of elements
```

```elixir
Enum.slice(1..10, 5, 100)
```
```elixir
Enum.slice(1..10, 5, 0)
```
```elixir
# using a negative start index
```

```elixir
Enum.slice(1..10, -6, 3)
```
```elixir
# out of bound start index (positive)
```

```elixir
Enum.slice(1..10, 10, 5)
```
```elixir
# out of bound start index (negative)
```

```elixir
Enum.slice(1..10, -11, 5)
```

## Function slide/3

Slides a single or multiple elements given by `range_or_single_index` from `enumerable`
to `insertion_index`.

The semantics of the range to be moved match the semantics of `Enum.slice/2`.
Specifically, that means:

  * Indices are normalized, meaning that negative indexes will be counted from the end
    (for example, -1 means the last element of the enumerable). This will result in *two*
    traversals of your enumerable on types like lists that don't provide a constant-time count.

  * If the normalized index range's `last` is out of bounds, the range is truncated to the last element.
  * If the normalized index range's `first` is out of bounds, the selected range for sliding
    will be empty, so you'll get back your input list.

  * Decreasing ranges (such as `5..0//1`) also select an empty range to be moved,
    so you'll get back your input list.

  * Ranges with any step but 1 will raise an error.

## Examples
```elixir
# Slide a single element
```

```elixir
Enum.slide([:a, :b, :c, :d, :e, :f, :g], 5, 1)
```
```elixir
# Slide a range of elements backward
```

```elixir
Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..5, 1)
```
```elixir
# Slide a range of elements forward
```

```elixir
Enum.slide([:a, :b, :c, :d, :e, :f, :g], 1..3, 5)
```
```elixir
# Slide with negative indices (counting from the end)
```

```elixir
Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..-1//1, 2)
```
```elixir
Enum.slide([:a, :b, :c, :d, :e, :f, :g], -4..-2, 1)
```
```elixir
# Insert at negative indices (counting from the end)
```

```elixir
Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3, -1)
```

## Function sort/1

Sorts the `enumerable` according to Erlang's term ordering.

This function uses the merge sort algorithm. Do not use this
function to sort structs, see `sort/2` for more information.

## Examples

```elixir
Enum.sort([3, 2, 1])
```

## Function sort/2

Sorts the `enumerable` by the given function.

This function uses the merge sort algorithm. The given function should compare
two arguments, and return `true` if the first argument precedes or is in the
same place as the second one.

## Examples

```elixir
Enum.sort([1, 2, 3], &(&1 >= &2))
```
The sorting algorithm will be stable as long as the given function
returns `true` for values considered equal:

```elixir
Enum.sort(["some", "kind", "of", "monster"], &(byte_size(&1) <= byte_size(&2)))
```
If the function does not return `true` for equal values, the sorting
is not stable and the order of equal terms may be shuffled.
For example:

```elixir
Enum.sort(["some", "kind", "of", "monster"], &(byte_size(&1) < byte_size(&2)))
```
## Ascending and descending

`sort/2` allows a developer to pass `:asc` or `:desc` as the sorting
function, which is a convenience for `<=/2` and `>=/2` respectively.

```elixir
Enum.sort([2, 3, 1], :asc)
```
```elixir
Enum.sort([2, 3, 1], :desc)
```
## Sorting structs

Do not use `</2`, `<=/2`, `>/2`, `>=/2` and friends when sorting structs.
That's because the built-in operators above perform structural comparison
and not a semantic one. Imagine we sort the following list of dates:

```elixir
dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
Enum.sort(dates)
```
Note that the returned result is incorrect, because `sort/1` by default uses
`<=/2`, which will compare their structure. When comparing structures, the
fields are compared in alphabetical order, which means the dates above will
be compared by `day`, `month` and then `year`, which is the opposite of what
we want.

For this reason, most structs provide a "compare" function, such as
`Date.compare/2`, which receives two structs and returns `:lt` (less-than),
`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the
sorting function, Elixir will automatically use the `compare/2` function
of said module:

```elixir
dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
Enum.sort(dates, Date)
```
To retrieve all dates in descending order, you can wrap the module in
a tuple with `:asc` or `:desc` as first element:

```elixir
dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
Enum.sort(dates, {:asc, Date})
```
```elixir
dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
Enum.sort(dates, {:desc, Date})
```

## Function sort_by/3

Sorts the mapped results of the `enumerable` according to the provided `sorter`
function.

This function maps each element of the `enumerable` using the
provided `mapper` function. The enumerable is then sorted by
the mapped elements using the `sorter` function, which defaults
to `Kernel.<=/2`.

`sort_by/3` differs from `sort/2` in that it only calculates the
comparison value for each element in the enumerable once instead of
once for each element in each comparison. If the same function is
being called on both elements, it's more efficient to use `sort_by/3`.

## Examples

Using the default `sorter` of `<=/2`:

```elixir
Enum.sort_by(["some", "kind", "of", "monster"], &byte_size/1)
```
Sorting by multiple properties - first by size, then by first letter
(this takes advantage of the fact that tuples are compared element-by-element):

```elixir
Enum.sort_by(["some", "kind", "of", "monster"], &{byte_size(&1), String.first(&1)})
```
Similar to `sort/2`, you can pass a custom sorter:

```elixir
Enum.sort_by(["some", "kind", "of", "monster"], &byte_size/1, &>=/2)
```
Or use `:asc` and `:desc`:

```elixir
Enum.sort_by(["some", "kind", "of", "monster"], &byte_size/1, :desc)
```
As in `sort/2`, avoid using the default sorting function to sort structs, as by default
it performs structural comparison instead of a semantic one. In such cases,
you shall pass a sorting function as third element or any module that implements
a `compare/2` function. For example, to sort users by their birthday in both
ascending and descending order respectively:

```elixir
users = [
  %{name: "Ellis", birthday: ~D[1943-05-11]},
  %{name: "Lovelace", birthday: ~D[1815-12-10]},
  %{name: "Turing", birthday: ~D[1912-06-23]}
]

Enum.sort_by(users, & &1.birthday, Date)
```
```elixir
Enum.sort_by(users, & &1.birthday, {:desc, Date})
```

## Function split/2

Splits the `enumerable` into two enumerables, leaving `count`
elements in the first one.

If `count` is a negative number, it starts counting from the
back to the beginning of the `enumerable`.

Be aware that a negative `count` implies the `enumerable`
will be enumerated twice: once to calculate the position, and
a second time to do the actual splitting.

## Examples

```elixir
Enum.split([1, 2, 3], 2)
```
```elixir
Enum.split([1, 2, 3], 10)
```
```elixir
Enum.split([1, 2, 3], 0)
```
```elixir
Enum.split([1, 2, 3], -1)
```
```elixir
Enum.split([1, 2, 3], -5)
```

## Function split_while/2

Splits enumerable in two at the position of the element for which
`fun` returns a falsy value (`false` or `nil`) for the first time.

It returns a two-element tuple with two lists of elements.
The element that triggered the split is part of the second list.

## Examples

```elixir
Enum.split_while([1, 2, 3, 4], fn x -> x < 3 end)
```
```elixir
Enum.split_while([1, 2, 3, 4], fn x -> x < 0 end)
```
```elixir
Enum.split_while([1, 2, 3, 4], fn x -> x > 0 end)
```

## Function split_with/2

Splits the `enumerable` in two lists according to the given function `fun`.

Splits the given `enumerable` in two lists by calling `fun` with each element
in the `enumerable` as its only argument. Returns a tuple with the first list
containing all the elements in `enumerable` for which applying `fun` returned
a truthy value, and a second list with all the elements for which applying
`fun` returned a falsy value (`false` or `nil`).

The elements in both the returned lists are in the same relative order as they
were in the original enumerable (if such enumerable was ordered, like a
list). See the examples below.

## Examples

```elixir
Enum.split_with([5, 4, 3, 2, 1, 0], fn x -> rem(x, 2) == 0 end)
```
```elixir
Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -> v < 0 end)
```
```elixir
Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -> v > 50 end)
```
```elixir
Enum.split_with(%{}, fn {_k, v} -> v > 50 end)
```

## Function sum/1

Returns the sum of all elements.

Raises `ArithmeticError` if `enumerable` contains a non-numeric value.

## Examples

```elixir
Enum.sum([1, 2, 3])
```
```elixir
Enum.sum(1..10)
```
```elixir
Enum.sum(1..10//2)
```

## Function take/2

Takes an `amount` of elements from the beginning or the end of the `enumerable`.

If a positive `amount` is given, it takes the `amount` elements from the
beginning of the `enumerable`.

If a negative `amount` is given, the `amount` of elements will be taken from the end.
The `enumerable` will be enumerated once to retrieve the proper index and
the remaining calculation is performed from the end.

If amount is `0`, it returns `[]`.

## Examples

```elixir
Enum.take([1, 2, 3], 2)
```
```elixir
Enum.take([1, 2, 3], 10)
```
```elixir
Enum.take([1, 2, 3], 0)
```
```elixir
Enum.take([1, 2, 3], -1)
```

## Function take_every/2

Returns a list of every `nth` element in the `enumerable`,
starting with the first element.

The first element is always included, unless `nth` is 0.

The second argument specifying every `nth` element must be a non-negative
integer.

## Examples

```elixir
Enum.take_every(1..10, 2)
```
```elixir
Enum.take_every(1..10, 0)
```
```elixir
Enum.take_every([1, 2, 3], 1)
```

## Function take_random/2

Takes `count` random elements from `enumerable`.

Note that this function will traverse the whole `enumerable` to
get the random sublist.

See `random/1` for notes on implementation and random seed.

## Examples

```elixir
# Although not necessary, let's seed the random algorithm
```

```elixir
:rand.seed(:exsss, {1, 2, 3})
Enum.take_random(1..10, 2)
```
```elixir
Enum.take_random(?a..?z, 5)
```

## Function take_while/2

Takes the elements from the beginning of the `enumerable` while `fun` returns
a truthy value.

## Examples

```elixir
Enum.take_while([1, 2, 3], fn x -> x < 3 end)
```

## Function to_list/1

Converts `enumerable` to a list.

## Examples

```elixir
Enum.to_list(1..3)
```

## Function uniq/1

Enumerates the `enumerable`, removing all duplicated elements.

## Examples

```elixir
Enum.uniq([1, 2, 3, 3, 2, 1])
```

## Function uniq_by/2

Enumerates the `enumerable`, by removing the elements for which
function `fun` returned duplicate elements.

The function `fun` maps every element to a term. Two elements are
considered duplicates if the return value of `fun` is equal for
both of them.

The first occurrence of each element is kept.

## Example

```elixir
Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)
```
```elixir
Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end)
```

## Function unzip/1

Opposite of `zip/2`. Extracts two-element tuples from the
given `enumerable` and groups them together.

It takes an `enumerable` with elements being two-element tuples and returns
a tuple with two lists, each of which is formed by the first and
second element of each tuple, respectively.

This function fails unless `enumerable` is or can be converted into a
list of tuples with *exactly* two elements in each tuple.

## Examples

```elixir
Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])
```
```elixir
Enum.unzip(%{a: 1, b: 2})
```

## Function with_index/2

Returns the `enumerable` with each element wrapped in a tuple
alongside its index.

May receive a function or an integer offset.

If an `offset` is given, it will index from the given offset instead of from
zero.

If a `function` is given, it will index by invoking the function for each
element and index (zero-based) of the enumerable.

## Examples

```elixir
Enum.with_index([:a, :b, :c])
```
```elixir
Enum.with_index([:a, :b, :c], 3)
```
```elixir
Enum.with_index([:a, :b, :c], fn element, index -> {index, element} end)
```

## Function zip/1

Zips corresponding elements from a finite collection of enumerables
into a list of tuples.

The zipping finishes as soon as any enumerable in the given collection completes.

## Examples

```elixir
Enum.zip([[1, 2, 3], [:a, :b, :c], ["foo", "bar", "baz"]])
```
```elixir
Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])
```

## Function zip/2

Zips corresponding elements from two enumerables into a list
of tuples.

The zipping finishes as soon as either enumerable completes.

## Examples

```elixir
Enum.zip([1, 2, 3], [:a, :b, :c])
```
```elixir
Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])
```

## Function zip_reduce/3

Reduces over all of the given enumerables, halting as soon as any enumerable is
empty.

The reducer will receive 2 args: a list of elements (one from each enum) and the
accumulator.

In practice, the behaviour provided by this function can be achieved with:

```elixir
Enum.reduce(Stream.zip(enums), acc, reducer)
```
But `zip_reduce/3` exists for convenience purposes.

## Examples

```elixir
enums = [[1, 1], [2, 2], [3, 3]]

Enum.zip_reduce(enums, [], fn elements, acc ->
  [List.to_tuple(elements) | acc]
end)
```
```elixir
enums = [[1, 2], %{a: 3, b: 4}, [5, 6]]

Enum.zip_reduce(enums, [], fn elements, acc ->
  [List.to_tuple(elements) | acc]
end)
```
## Function zip_reduce/4

Reduces over two enumerables halting as soon as either enumerable is empty.

In practice, the behaviour provided by this function can be achieved with:

```elixir
Enum.reduce(Stream.zip(left, right), acc, reducer)
```
But `zip_reduce/4` exists for convenience purposes.

## Examples

```elixir
Enum.zip_reduce([1, 2], [3, 4], 0, fn x, y, acc -> x + y + acc end)
```
```elixir
Enum.zip_reduce([1, 2], [3, 4], [], fn x, y, acc -> [x + y | acc] end)
```
## Function zip_with/2

Zips corresponding elements from a finite collection of enumerables
into list, transforming them with the `zip_fun` function as it goes.

The first element from each of the enums in `enumerables` will be put
into a list which is then passed to the 1-arity `zip_fun` function.
Then, the second elements from each of the enums are put into a list
and passed to `zip_fun`, and so on until any one of the enums in
`enumerables` runs out of elements.

Returns a list with all the results of calling `zip_fun`.

## Examples

```elixir
Enum.zip_with([[1, 2], [3, 4], [5, 6]], fn [x, y, z] -> x + y + z end)
```
```elixir
Enum.zip_with([[1, 2], [3, 4]], fn [x, y] -> x + y end)
```

## Function zip_with/3

Zips corresponding elements from two enumerables into a list, transforming them with
the `zip_fun` function as it goes.

The corresponding elements from each collection are passed to the provided 2-arity `zip_fun`
function in turn. Returns a list that contains the result of calling `zip_fun` for each pair of
elements.

The zipping finishes as soon as either enumerable runs out of elements.

## Zipping Maps

It's important to remember that zipping inherently relies on order.
If you zip two lists you get the element at the index from each list in turn.
If we zip two maps together it's tempting to think that you will get the given
key in the left map and the matching key in the right map, but there is no such
guarantee because map keys are not ordered! Consider the following:

```elixir
left = %{:a => 1, 1 => 3}
right = %{:a => 1, :b => :c}
Enum.zip(left, right)
# [{{1, 3}, {:a, 1}}, {{:a, 1}, {:b, :c}}]
```
As you can see `:a` does not get paired with `:a`. If this is what you want,
you should use `Map.merge/3`.

## Examples

```elixir
Enum.zip_with([1, 2], [3, 4], fn x, y -> x + y end)
```
```elixir
Enum.zip_with([1, 2], [3, 4, 5, 6], fn x, y -> x + y end)
```
```elixir
Enum.zip_with([1, 2, 5, 6], [3, 4], fn x, y -> x + y end)
```

## Type index

Zero-based index. It can also be a negative integer.
